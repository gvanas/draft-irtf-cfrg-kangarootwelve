<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>KangarooTwelve</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 Specifications">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Inner function F">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Tree hashing over F">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 length_encode( x )">
<link href="#rfc.section.3" rel="Chapter" title="3 Test vectors">
<link href="#rfc.section.4" rel="Chapter" title="4 IANA Considerations">
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="6 References">
<link href="#rfc.references.1" rel="Chapter" title="6.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="6.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Pseudocode">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Keccak-p[1600,n_r=12]">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 KangarooTwelve">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.47.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Viguier, B., Wong, D., Ed., Van Assche, G., Ed., Dang, Q., Ed., and J. Daemen, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-irtf-cfrg-kangarootwelve-04" />
  <meta name="dct.issued" scheme="ISO8601" content="2020-21" />
  <meta name="dct.abstract" content="This document defines the KangarooTwelve eXtendable Output Function (XOF), a hash function with output of arbitrary length.  It provides an efficient and secure hashing primitive, which is able to exploit the parallelism of the implementation in a scalable way.  It uses tree hashing over a round-reduced version of SHAKE128 as underlying primitive. This document builds up on the definitions of the permutations and of the sponge construction in [FIPS 202], and is meant to serve as a stable reference and an implementation guide. " />
  <meta name="description" content="This document defines the KangarooTwelve eXtendable Output Function (XOF), a hash function with output of arbitrary length.  It provides an efficient and secure hashing primitive, which is able to exploit the parallelism of the implementation in a scalable way.  It uses tree hashing over a round-reduced version of SHAKE128 as underlying primitive. This document builds up on the definitions of the permutations and of the sponge construction in [FIPS 202], and is meant to serve as a stable reference and an implementation guide. " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Crypto Forum</td>
<td class="right">B. Viguier</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Radboud University</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">D. Wong, Ed.</td>
</tr>
<tr>
<td class="left">Expires: March 25, 2021</td>
<td class="right">Facebook</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">G. Van Assche, Ed.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">STMicroelectronics</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Q. Dang, Ed.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">NIST</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">J. Daemen, Ed.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Radboud University</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">September 21, 2020</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">KangarooTwelve<br />
  <span class="filename">draft-irtf-cfrg-kangarootwelve-04</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines the KangarooTwelve eXtendable Output Function (XOF), a hash function with output of arbitrary length.  It provides an efficient and secure hashing primitive, which is able to exploit the parallelism of the implementation in a scalable way.  It uses tree hashing over a round-reduced version of SHAKE128 as underlying primitive.</p>
<p>This document builds up on the definitions of the permutations and of the sponge construction in [FIPS 202], and is meant to serve as a stable reference and an implementation guide.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 25, 2021.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Conventions</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Specifications</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Inner function F</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Tree hashing over F</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">length_encode( x )</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Test vectors</a>
</li>
<li>4.   <a href="#rfc.section.4">IANA Considerations</a>
</li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a>
</li>
<li>6.   <a href="#rfc.references">References</a>
</li>
<ul><li>6.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>6.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Pseudocode</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Keccak-p[1600,n_r=12]</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">KangarooTwelve</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This document defines the KangarooTwelve eXtendable Output Function (XOF) <a href="#K12" class="xref">[K12]</a>, i.e. a generalization of a hash function that can return an output of arbitrary length.  KangarooTwelve is based on a Keccak-p permutation specified in <a href="#FIPS202" class="xref">[FIPS202]</a> and has a higher speed than SHAKE and SHA-3.</p>
<p id="rfc.section.1.p.2">The SHA-3 functions process data in a serial manner and are unable to optimally exploit parallelism available in modern CPU architectures.  Similar to ParallelHash <a href="#SP800-185" class="xref">[SP800-185]</a>, KangarooTwelve splits the input message into fragments to exploit available parallelism. It then applies an inner hash function F on each of them separately before applying F again on the concatenation of the digests.  It makes use of Sakura coding for ensuring soundness of the tree hashing mode <a href="#SAKURA" class="xref">[SAKURA]</a>.  The inner hash function F is a sponge function and uses a round-reduced version of the permutation Keccak-f used in SHA-3, making it faster than ParallelHash.  Its security builds up on the scrutiny that Keccak has received since its publication <a href="#KECCAK_CRYPTANALYSIS" class="xref">[KECCAK_CRYPTANALYSIS]</a>.</p>
<p id="rfc.section.1.p.3">With respect to <a href="#FIPS202" class="xref">[FIPS202]</a> and <a href="#SP800-185" class="xref">[SP800-185]</a> functions, KangarooTwelve features the following advantages:</p>
<p></p>

<ul>
<li>Unlike SHA3-224, SHA3-256, SHA3-384, SHA3-512, KangarooTwelve has an extendable output.</li>
<li>Unlike any <a href="#FIPS202" class="xref">[FIPS202]</a> defined function, similarly to functions defined in <a href="#SP800-185" class="xref">[SP800-185]</a>, KangarooTwelve allows the use of a customization string.</li>
<li>Unlike any <a href="#FIPS202" class="xref">[FIPS202]</a> and <a href="#SP800-185" class="xref">[SP800-185]</a> functions but ParallelHash, KangarooTwelve splits the input message into fragments to exploit available parallelism.</li>
<li>Unlike ParallelHash, KangarooTwelve does not have overhead when processing short messages.</li>
<li>The Keccak-f permutation in KangarooTwelve has half the number of rounds of the one used in SHA3, making it faster than any function defined in <a href="#FIPS202" class="xref">[FIPS202]</a> and <a href="#SP800-185" class="xref">[SP800-185]</a>.</li>
</ul>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Conventions</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<p id="rfc.section.1.1.p.2">The following notations are used throughout the document:</p>
<p></p>

<dl>
<dt>`...`</dt>
<dd style="margin-left: 8">denotes a string of bytes given in hexadecimal. For example, `0B 80`.</dd>
<dt>|s|</dt>
<dd style="margin-left: 8">denotes the length of a byte string `s`.  For example, |`FF FF`| = 2.</dd>
<dt>`00`^b</dt>
<dd style="margin-left: 8">denotes a byte string consisting of the concatenation of b bytes `00`. For example, `00`^7 = `00 00 00 00 00 00 00`.</dd>
<dt>`00`^0</dt>
<dd style="margin-left: 8">denotes the empty byte-string.</dd>
<dt>a||b</dt>
<dd style="margin-left: 8">denotes the concatenation of two strings a and b.  For example, `10`||`F1` = `10 F1`</dd>
<dt>s[n:m]</dt>
<dd style="margin-left: 8">denotes the selection of bytes from n (inclusive) to m (exclusive) of a string s. The indexing of a byte-string starts at 0.  For example, for s = `A5 C6 D7`, s[0:1] = `A5` and s[1:3] = `C6 D7`.</dd>
<dt>s[n:]</dt>
<dd style="margin-left: 8">denotes the selection of bytes from n to the end of a string s.  For example, for s = `A5 C6 D7`, s[0:] = `A5 C6 D7` and s[2:] = `D7`.</dd>
</dl>
<p id="rfc.section.1.1.p.4">In the following, x and y are byte strings of equal length:</p>
<p></p>

<dl>
<dt>x^=y</dt>
<dd style="margin-left: 8">denotes x takes the value x XOR y.</dd>
<dt>x &amp; y</dt>
<dd style="margin-left: 8">denotes x AND y.</dd>
</dl>
<p id="rfc.section.1.1.p.6">In the following, x and y are integers:</p>
<p></p>

<dl>
<dt>x+=y</dt>
<dd style="margin-left: 8">denotes x takes the value x + y.</dd>
<dt>x-=y</dt>
<dd style="margin-left: 8">denotes x takes the value x - y.</dd>
<dt>x**y</dt>
<dd style="margin-left: 8">denotes the exponentiation of x by y.</dd>
</dl>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Specifications</h1>
<p id="rfc.section.2.p.1">KangarooTwelve is an eXtendable Output Function (XOF).  It takes as input two byte-strings (M, C) and a positive integer L where </p>

<dl>
<dt>M</dt>
<dd style="margin-left: 8">byte-string, is the Message and</dd>
<dt>C</dt>
<dd style="margin-left: 8">byte-string, is an OPTIONAL Customization string and</dd>
<dt>L</dt>
<dd style="margin-left: 8">positive integer, the requested number of output bytes.</dd>
</dl>
<p id="rfc.section.2.p.2">The Customization string MAY serve as domain separation.  It is typically a short string such as a name or an identifier (e.g. URI, ODI...)</p>
<p id="rfc.section.2.p.3">By default, the Customization string is the empty string. For an API that does not support a customization string input, C MUST be the empty string.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Inner function F</h1>
<p id="rfc.section.2.1.p.1">The inner function F makes use of the permutation Keccak-p[1600,n_r=12], i.e., a version of the permutation Keccak-f[1600] used in SHAKE and SHA-3 instances reduced to its last n_r=12 rounds and specified in FIPS 202, sections 3.3 and 3.4 <a href="#FIPS202" class="xref">[FIPS202]</a>.  KP denotes this permutation.</p>
<p id="rfc.section.2.1.p.2">F is a sponge function calling this permutation KP with a rate of 168 bytes or 1344 bits. It follows that F has a capacity of 1600 - 1344 = 256 bits or 32 bytes.</p>
<p id="rfc.section.2.1.p.3">The sponge function F takes:</p>

<dl>
<dt>input</dt>
<dd style="margin-left: 8">byte-string of positive length, the input bytes and</dd>
<dt>outputByteLen</dt>
<dd style="margin-left: 8">positive integer, the length of the output in bytes</dd>
</dl>
<p id="rfc.section.2.1.p.4">First non-multiple of 168-bytes-length inputs are padded with zeroes to the next multiple of 168 bytes while inputs multiple of 168 bytes are kept as is.  Then a byte `80` is XORed to the last byte of the padded message and the resulting string is split into a sequence of 168-byte blocks.</p>
<p id="rfc.section.2.1.p.5">Inputs of length 0 bytes do not happen as a result of the tree hashing mode defined in section 2.2.</p>
<p id="rfc.section.2.1.p.6">As defined by the sponge construction, the process operates on a state and consists of two phases: the absorbing phase that processes the input and the squeezing phase that produces the output.</p>
<p id="rfc.section.2.1.p.7">In the absorbing phase the state is initialized to all-zero. The message blocks are XORed into the first 168 bytes of the state.  Each block absorbed is followed with an application of KP to the state.</p>
<p id="rfc.section.2.1.p.8">In the squeezing phase output is formed by taking the first 168 bytes of the state, repeated as many times as necessary until outputByteLen bytes are obtained, interleaved with the application of KP to the state.</p>
<p id="rfc.section.2.1.p.9">The definition of the function F equivalently implements the pad10*1 rule.  It assumes an at least one-byte-long input where the last byte is in the `01`-`7F` range, and this is the case in KangarooTwelve.  This last byte serves as domain separation and integrates the first bit of padding of the pad10*1 rule (hence it cannot be `00`).  Additionally, it must leave room for the second bit of padding (hence it cannot have the MSB set to 1), should it be the last byte of the block.  For more details, refer to Section 6.1 of <a href="#K12" class="xref">[K12]</a>.</p>
<p id="rfc.section.2.1.p.10">A pseudocode version is available as follows:</p>
<pre>
  F(input, outputByteLen):
    offset = 0
    state = `00`^200

    # === Absorb complete blocks ===
    while offset &lt; |input| - 168
        state ^= input[offset : offset + 168] || `00`^32
        state = KP(state)
        offset += 168

    # === Absorb last block and treatment of padding ===
    LastBlockLength = |input| - offset
    state ^= input[offset:] || `00`^(200-LastBlockLength)
    state ^= `00`^167 || `80` || `00`^32
    state = KP(state)

    # === Squeeze ===
    output = `00`^0
    while outputByteLen &gt; 168
        output = output || state[0:168]
        outputByteLen -= 168
        state = KP(state)

    output = output || state[0:outputByteLen]

    return output
    end</pre>
<p></p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> Tree hashing over F</h1>
<p id="rfc.section.2.2.p.1">On top of the sponge function F, KangarooTwelve uses a Sakura-compatible tree hash mode <a href="#SAKURA" class="xref">[SAKURA]</a>.  First, merge M and the OPTIONAL C to a single input string S in a reversible way. length_encode( |C| ) gives the length in bytes of C as a byte-string.  See <a href="#RE" class="xref">Section 2.3</a>.</p>
<pre>
          S = M || C || length_encode( |C| ) </pre>
<p></p>
<p id="rfc.section.2.2.p.3">Then, split S into n chunks of 8192 bytes.</p>
<pre>
          S = S_0 || .. || S_(n-1)
            |S_0| = .. = |S_(n-2)| = 8192 bytes
            |S_(n-1)| &lt;= 8192 bytes </pre>
<p></p>
<p id="rfc.section.2.2.p.5">From S_1 .. S_(n-1), compute the 32-byte Chaining Values CV_1 .. CV_(n-1).  In order to be optimally efficient, this computation SHOULD exploit the parallelism available on the platform such as SIMD instructions.</p>
<pre>
             CV_i    = F( S_i||`0B`, 32 )</pre>
<p></p>
<p id="rfc.section.2.2.p.7">Compute the final node: FinalNode.  </p>

<ul>
<li>If |S| &lt;= 8192 bytes, FinalNode = S</li>
<li>Otherwise compute FinalNode as follows:</li>
</ul>
<pre>
          FinalNode = S_0 || `03 00 00 00 00 00 00 00`
          FinalNode = FinalNode || CV_1
                ..
          FinalNode = FinalNode || CV_(n-1)
          FinalNode = FinalNode || length_encode(n-1)
          FinalNode = FinalNode || `FF FF`</pre>
<p></p>
<p id="rfc.section.2.2.p.9">Finally, KangarooTwelve output is retrieved: </p>

<ul><li>If |S| &lt;= 8192 bytes, from F( FinalNode||`07`, L )</li></ul>
<pre>      KangarooTwelve( M, C, L ) = F( FinalNode||`07`, L )
        </pre>
<p></p>
<p></p>

<ul><li>Otherwise from F( FinalNode||`06`, L )</li></ul>
<pre>      KangarooTwelve( M, C, L ) = F( FinalNode||`06`, L )
      </pre>
<p></p>
<p id="rfc.section.2.2.p.13">The following figure illustrates the computation flow of KangarooTwelve for |S| &lt;= 8192 bytes:</p>
<pre>
          +--------------+  F(..||`07`, L)
          |      S       |-----------------&gt;  output
          +--------------+</pre>
<p></p>
<p id="rfc.section.2.2.p.15">The following figure illustrates the computation flow of KangarooTwelve for |S| &gt; 8192 bytes and where length_encode( x ) is abbreviated as l_e( x ):</p>
<pre>
                             +--------------+
                             |     S_0      |
                             +--------------+
                                   ||
                             +--------------+
                             | `03`||`00`^7 |
                             +--------------+
                                   ||
+---------+  F(..||`0B`,32)  +--------------+
|   S_1   |-----------------&gt;|     CV_1     |
+---------+                  +--------------+
                                   ||
+---------+  F(..||`0B`,32)  +--------------+
|   S_2   |-----------------&gt;|     CV_2     |
+---------+                  +--------------+
                                   ||
          ...                      ...
                                   ||
+---------+  F(..||`0B`,32)  +--------------+
| S_(n-1) |-----------------&gt;|   CV_(n-1)   |
+---------+                  +--------------+
                                   ||
                             +--------------+
                             |  l_e( n-1 )  |
                             +--------------+
                                   ||
                             +--------------+  F(..||`06`, L)
                             |   `FF FF`    |-----------------&gt;  output
                             +--------------+</pre>
<p></p>
<p id="rfc.section.2.2.p.17">A pseudocode version is provided in <a href="#K_PC" class="xref">Appendix A.2</a>.</p>
<p id="rfc.section.2.2.p.18">The table below gathers the values of the domain separation bytes used by the tree hash mode:</p>
<pre>
        +--------------------+------------------+
        |   Type             |       Byte       |
        +--------------------+------------------+
        |  SingleNode        |       `07`       |
        |                    |                  |
        |  IntermediateNode  |       `0B`       |
        |                    |                  |
        |  FinalNode         |       `06`       |
        +--------------------+------------------+</pre>
<p></p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#RE" id="RE">length_encode( x )</a>
</h1>
<p id="rfc.section.2.3.p.1">The function length_encode takes as inputs a non negative integer x &lt; 256**255 and outputs a string of bytes x_(n-1) || .. || x_0 || n where</p>
<pre>             x = sum from i=0..n-1 of 256**i * x_i</pre>
<p></p>
<p id="rfc.section.2.3.p.3">and where n is the smallest non-negative integer such that x &lt; 256**n.  n is also the length of x_(n-1) || .. || x_0.</p>
<p id="rfc.section.2.3.p.4">As example, length_encode(0) = `00`, length_encode(12) = `0C 01` and length_encode(65538) = `01 00 02 03`</p>
<p id="rfc.section.2.3.p.5">A pseudocode version is as follows.</p>
<pre>
  length_encode(x):
    S = `00`^0

    while x &gt; 0
        S = x mod 256 || S
        x = x / 256

    S = S || length(S)

    return S
    end</pre>
<p></p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Test vectors</h1>
<p id="rfc.section.3.p.1">Test vectors are based on the repetition of the pattern `00 01 .. FA` with a specific length. ptn(n) defines a string by repeating the pattern `00 01 .. FA` as many times as necessary and truncated to n bytes e.g.  </p>
<pre>    Pattern for a length of 17 bytes:
    ptn(17) =
      `00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10`</pre>
<p></p>
<pre>    Pattern for a length of 17**2 bytes:
    ptn(17**2) =
      `00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
       10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F
       20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F
       30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F
       40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F
       50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F
       60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F
       70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F
       80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
       90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F
       A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF
       B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF
       C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
       D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF
       E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF
       F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA
       00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
       10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F
       20 21 22 23 24 25`</pre>
<p></p>
<pre>  KangarooTwelve(M=`00`^0, C=`00`^0, 32):
    `1A C2 D4 50 FC 3B 42 05 D1 9D A7 BF CA 1B 37 51
     3C 08 03 57 7A C7 16 7F 06 FE 2C E1 F0 EF 39 E5`

  KangarooTwelve(M=`00`^0, C=`00`^0, 64):
    `1A C2 D4 50 FC 3B 42 05 D1 9D A7 BF CA 1B 37 51
     3C 08 03 57 7A C7 16 7F 06 FE 2C E1 F0 EF 39 E5
     42 69 C0 56 B8 C8 2E 48 27 60 38 B6 D2 92 96 6C
     C0 7A 3D 46 45 27 2E 31 FF 38 50 81 39 EB 0A 71`

  KangarooTwelve(M=`00`^0, C=`00`^0, 10032), last 32 bytes:
    `E8 DC 56 36 42 F7 22 8C 84 68 4C 89 84 05 D3 A8
     34 79 91 58 C0 79 B1 28 80 27 7A 1D 28 E2 FF 6D`

  KangarooTwelve(M=ptn(1 bytes), C=`00`^0, 32):
    `2B DA 92 45 0E 8B 14 7F 8A 7C B6 29 E7 84 A0 58
     EF CA 7C F7 D8 21 8E 02 D3 45 DF AA 65 24 4A 1F`

  KangarooTwelve(M=ptn(17 bytes), C=`00`^0, 32):
    `6B F7 5F A2 23 91 98 DB 47 72 E3 64 78 F8 E1 9B
     0F 37 12 05 F6 A9 A9 3A 27 3F 51 DF 37 12 28 88`

  KangarooTwelve(M=ptn(17**2 bytes), C=`00`^0, 32):
    `0C 31 5E BC DE DB F6 14 26 DE 7D CF 8F B7 25 D1
     E7 46 75 D7 F5 32 7A 50 67 F3 67 B1 08 EC B6 7C`

  KangarooTwelve(M=ptn(17**3 bytes), C=`00`^0, 32):
    `CB 55 2E 2E C7 7D 99 10 70 1D 57 8B 45 7D DF 77
     2C 12 E3 22 E4 EE 7F E4 17 F9 2C 75 8F 0D 59 D0`

  KangarooTwelve(M=ptn(17**4 bytes), C=`00`^0, 32):
    `87 01 04 5E 22 20 53 45 FF 4D DA 05 55 5C BB 5C
     3A F1 A7 71 C2 B8 9B AE F3 7D B4 3D 99 98 B9 FE`

  KangarooTwelve(M=ptn(17**5 bytes), C=`00`^0, 32):
    `84 4D 61 09 33 B1 B9 96 3C BD EB 5A E3 B6 B0 5C
     C7 CB D6 7C EE DF 88 3E B6 78 A0 A8 E0 37 16 82`

  KangarooTwelve(M=ptn(17**6 bytes), C=`00`^0, 32):
    `3C 39 07 82 A8 A4 E8 9F A6 36 7F 72 FE AA F1 32
     55 C8 D9 58 78 48 1D 3C D8 CE 85 F5 8E 88 0A F8`

  KangarooTwelve(M=`00`^0, C=ptn(1 bytes), 32):
    `FA B6 58 DB 63 E9 4A 24 61 88 BF 7A F6 9A 13 30
     45 F4 6E E9 84 C5 6E 3C 33 28 CA AF 1A A1 A5 83`

  KangarooTwelve(M=`FF`, C=ptn(41 bytes), 32):
    `D8 48 C5 06 8C ED 73 6F 44 62 15 9B 98 67 FD 4C
     20 B8 08 AC C3 D5 BC 48 E0 B0 6B A0 A3 76 2E C4`

  KangarooTwelve(M=`FF FF FF`, C=ptn(41**2), 32):
    `C3 89 E5 00 9A E5 71 20 85 4C 2E 8C 64 67 0A C0
     13 58 CF 4C 1B AF 89 44 7A 72 42 34 DC 7C ED 74`

  KangarooTwelve(M=`FF FF FF FF FF FF FF`, C=ptn(41**3 bytes), 32):
    `75 D2 F8 6A 2E 64 45 66 72 6B 4F BC FC 56 57 B9
     DB CF 07 0C 7B 0D CA 06 45 0A B2 91 D7 44 3B CF`</pre>
<p></p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.4.p.1">None.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.5.p.1">This document is meant to serve as a stable reference and an implementation guide for the KangarooTwelve eXtendable Output Function.  It relies on the cryptanalysis of Keccak and provides with the same security strength as SHAKE128, i.e., 128 bits of security against all attacks.</p>
<p id="rfc.section.5.p.2">To be more precise, KangarooTwelve is made of two layers: </p>

<ul>
<li>The inner function F. This layer relies on cryptanalysis.  KangarooTwelve's F function is exactly Keccak[r=1344, c=256] (as in SHAKE128) reduced to 12 rounds. Any reduced-round cryptanalysis on Keccak is also a reduced-round cryptanalysis of KangarooTwelve's F (provided the number of rounds attacked is not higher than 12).</li>
<li>The tree hashing over F. This layer is a mode on top of F that does not introduce any vulnerability thanks to the use of Sakura coding proven secure in <a href="#SAKURA" class="xref">[SAKURA]</a>.</li>
</ul>
<p id="rfc.section.5.p.3">This reasoning is detailed and formalized in <a href="#K12" class="xref">[K12]</a>.</p>
<p id="rfc.section.5.p.4">To achieve 128-bit security strength, the output L must be chosen long enough so that there are no generic attacks that violate 128-bit security.  So for 128-bit (second) preimage security the output should be at least 128 bits, for 128-bit of security against multi-target preimage attacks with T targets the output should be at least 128+log_2(T) bits and for 128-bit collision security the output should be at least 256 bits.</p>
<p id="rfc.section.5.p.5">Furthermore, when the output length is at least 256 bits, KangarooTwelve achieves NIST's post-quantum security level 2 <a href="#NISTPQ" class="xref">[NISTPQ]</a>.</p>
<p id="rfc.section.5.p.6">Implementing a MAC with KangarooTwelve SHOULD use a HASH-then-MAC construction.  This document recommends a method called HopMAC, defined as follows:</p>
<pre>   HopMAC(Key, M, C, L) = K12(Key, K12(M, C, 32), L) </pre>
<p></p>
<p id="rfc.section.5.p.8">Similarly to HMAC, HopMAC consists of two calls: an inner call compressing the message M and the optional customization string C to a digest, and an outer call computing the tag from the key and the digest.</p>
<p id="rfc.section.5.p.9">Unlike HMAC, the inner call to KangarooTwelve in HopMAC is keyless and does not require additional protection against side channel attacks (SCA).  Consequently, in an implementation that has to protect the HopMAC key against SCA only the outer call does need protection, and this amounts to a single execution of the underlying permutation.</p>
<h1 id="rfc.references">
<a href="#rfc.references">6.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">6.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="FIPS202">[FIPS202]</b></td>
<td class="top">
<a>National Institute of Standards and Technology</a>, "<a>FIPS PUB 202 - SHA-3 Standard:  Permutation-Based Hash and Extendable-Output Functions</a>", WWW http://dx.doi.org/10.6028/NIST.FIPS.202, August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="SP800-185">[SP800-185]</b></td>
<td class="top">
<a>National Institute of Standards and Technology</a>, "<a>NIST Special Publication 800-185 SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash and ParallelHash</a>", WWW https://doi.org/10.6028/NIST.SP.800-185, December 2016.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">6.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="K12">[K12]</b></td>
<td class="top">
<a>Bertoni, G.</a>, <a>Daemen, J.</a>, <a>Peeters, M.</a>, <a>Van Assche, G.</a> and <a>R. Van Keer</a>, "<a>KangarooTwelve: fast hashing based on Keccak-p</a>", WWW https://link.springer.com/chapter/10.1007/978-3-319-93387-0_21, WWW http://eprint.iacr.org/2016/770.pdf, July 2018.</td>
</tr>
<tr>
<td class="reference"><b id="KECCAK_CRYPTANALYSIS">[KECCAK_CRYPTANALYSIS]</b></td>
<td class="top">
<a>Keccak Team</a>, "<a>Summary of Third-party cryptanalysis of Keccak</a>", WWW https://www.keccak.team/third_party.html, 2017.</td>
</tr>
<tr>
<td class="reference"><b id="NISTPQ">[NISTPQ]</b></td>
<td class="top">
<a>National Institute of Standards and Technology</a>, "<a>Submission Requirements and Evaluation Criteria for the Post-Quantum Cryptography Standardization Process</a>", WWW https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-for-proposals-final-dec-2016.pdf, December 2016.</td>
</tr>
<tr>
<td class="reference"><b id="SAKURA">[SAKURA]</b></td>
<td class="top">
<a>Bertoni, G.</a>, <a>Daemen, J.</a>, <a>Peeters, M.</a> and <a>G. Van Assche</a>, "<a>Sakura: a flexible coding for tree hashing</a>", WWW https://link.springer.com/chapter/10.1007/978-3-319-07536-5_14, WWW http://eprint.iacr.org/2013/231.pdf, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="XKCP">[XKCP]</b></td>
<td class="top">
<a>Bertoni, G.</a>, <a>Daemen, J.</a>, <a>Peeters, M.</a>, <a>Van Assche, G.</a> and <a>R. Van Keer</a>, "<a>eXtended Keccak Code Package</a>", WWW https://github.com/XKCP/XKCP, September 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#pseudocode" id="pseudocode">Pseudocode</a>
</h1>
<p id="rfc.section.A.p.1">The sub-sections of this appendix contain pseudocode definitions of KangarooTwelve. A standalone Python version is also available in the Keccak Code Package <a href="#XKCP" class="xref">[XKCP]</a> and in <a href="#K12" class="xref">[K12]</a> </p>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#Keccak_PC" id="Keccak_PC">Keccak-p[1600,n_r=12]</a>
</h1>
<pre>
KP(state):
  RC[0]  = `8B 80 00 80 00 00 00 00`
  RC[1]  = `8B 00 00 00 00 00 00 80`
  RC[2]  = `89 80 00 00 00 00 00 80`
  RC[3]  = `03 80 00 00 00 00 00 80`
  RC[4]  = `02 80 00 00 00 00 00 80`
  RC[5]  = `80 00 00 00 00 00 00 80`
  RC[6]  = `0A 80 00 00 00 00 00 00`
  RC[7]  = `0A 00 00 80 00 00 00 80`
  RC[8]  = `81 80 00 80 00 00 00 80`
  RC[9]  = `80 80 00 00 00 00 00 80`
  RC[10] = `01 00 00 80 00 00 00 00`
  RC[11] = `08 80 00 80 00 00 00 80`

  for x from 0 to 4
    for y from 0 to 4
      lanes[x][y] = state[8*(x+5*y):8*(x+5*y)+8]

  for round from 0 to 11
    # theta
    for x from 0 to 4
      C[x] = lanes[x][0]
      C[x] ^= lanes[x][1]
      C[x] ^= lanes[x][2]
      C[x] ^= lanes[x][3]
      C[x] ^= lanes[x][4]
    for x from 0 to 4
      D[x] = C[(x+4) mod 5] ^ ROL64(C[(x+1) mod 5], 1)
    for y from 0 to 4
      for x from 0 to 4
        lanes[x][y] = lanes[x][y]^D[x]

    # rho and pi
    (x, y) = (1, 0)
    current = lanes[x][y]
    for t from 0 to 23
      (x, y) = (y, (2*x+3*y) mod 5)
      (current, lanes[x][y]) =
          (lanes[x][y], ROL64(current, (t+1)*(t+2)/2))

    # chi
    for y from 0 to 4
      for x from 0 to 4
        T[x] = lanes[x][y]
      for x from 0 to 4
        lanes[x][y] = T[x] ^((not T[(x+1) mod 5]) &amp; T[(x+2) mod 5])

    # iota
    lanes[0][0] ^= RC[round]

  state = `00`^0
  for x from 0 to 4
    for y from 0 to 4
      state = state || lanes[x][y]

  return state
  end
</pre>
<p></p>
<p id="rfc.section.A.1.p.2">where ROL64(x, y) is a rotation of the 'x' 64-bit word toward the bits with higher indexes by 'y' positions. The 8-bytes byte-string x is interpreted as a 64-bit word in little-endian format.  </p>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#K_PC" id="K_PC">KangarooTwelve</a>
</h1>
<pre>
KangarooTwelve(inputMessage, customString, outputByteLen):
  S = inputMessage || customString
  S = S || length_encode( |customString| )

  if |S| &lt;= 8192
      return F(S || `07`, outputByteLen)
  else
      # === Kangaroo hopping ===
      FinalNode = S[0:8192] || `03` || `00`^7
      offset = 8192
      numBlock = 0
      while offset &lt; |S|
          blockSize = min( |S| - offset, 8192)
          CV = F(S[offset : offset + blockSize] || `0B`, 32)
          FinalNode = FinalNode || CV
          numBlock += 1
          offset   += blockSize

      FinalNode = FinalNode || length_encode( numBlock ) || `FF FF`

      return F(FinalNode || `06`, outputByteLen)
  end
</pre>
<p></p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Beno&#238;t Viguier</span> 
	  <span class="n hidden">
		<span class="family-name">Viguier</span>
	  </span>
	</span>
	<span class="org vcardline">Radboud University</span>
	<span class="adr">
	  <span class="vcardline">Toernooiveld 212</span>

	  <span class="vcardline">
		<span class="locality">Nijmegen</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">The Netherlands</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:b.viguier@cs.ru.nl">b.viguier@cs.ru.nl</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">David Wong</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Wong</span>
	  </span>
	</span>
	<span class="org vcardline">Facebook</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:davidwong.crypto@gmail.com">davidwong.crypto@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Gilles Van Assche</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Van Assche</span>
	  </span>
	</span>
	<span class="org vcardline">STMicroelectronics</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:gilles.vanassche@st.com">gilles.vanassche@st.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Quynh Dang</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Dang</span>
	  </span>
	</span>
	<span class="org vcardline">National Institute of Standards and Technology</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:quynh.dang@nist.gov">quynh.dang@nist.gov</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Joan Daemen</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Daemen</span>
	  </span>
	</span>
	<span class="org vcardline">Radboud University</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:joan@cs.ru.nl">joan@cs.ru.nl</a></span>

  </address>
</div>

</body>
</html>
